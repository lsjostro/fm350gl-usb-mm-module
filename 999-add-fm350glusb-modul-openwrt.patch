--- a/meson.build
+++ b/meson.build
@@ -357,6 +357,7 @@ plugins_options_reqs = {
   'wavecom': {'available': true, 'shared': []},
   'x22x': {'available': true, 'shared': []},
   'zte': {'available': true, 'shared': ['icera']},
+  'fm350gl': {'available': true, 'shared': []},
 }
 
 plugins_shared = {}
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -102,3 +102,4 @@ option('gtk_doc', type: 'boolean', value
 option('bash_completion', type: 'boolean', value: true, description: 'install bash completion files')
 
 option('fuzzer', type: 'boolean', value: false, description: 'build fuzzer tests')
+option('plugin_fm350gl', type: 'feature', value: 'auto', description: 'enable fm350gl plugin support')
--- /dev/null
+++ b/src/plugins/fm350gl/77-mm-fm350gl.rules
@@ -0,0 +1,36 @@
+# do not edit this file, it will be overwritten on update
+
+ACTION!="add|change|move|bind", GOTO="mm_fm350gl_port_types_end"
+SUBSYSTEMS=="usb", ATTRS{idVendor}=="0e8d", GOTO="mm_fm350gl_port_types_vendorcheck"
+GOTO="mm_fm350gl_port_types_end"
+
+# FM350GL devices ---------------------------
+
+LABEL="mm_fm350gl_port_types_vendorcheck"
+SUBSYSTEMS=="usb", ATTRS{bInterfaceNumber}=="?*", ENV{.MM_USBIFNUM}="$attr{bInterfaceNumber}"
+
+#AT+GTUSBMODE=40 (0e8d:7126)  RNDIS+AT+AP(GNSS)+META+DEBUG+NPT+ADB
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="00", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="01", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="02", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="03", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="04", SUBSYSTEM=="tty", ENV{ID_MM_PORT_TYPE_AT_PRIMARY}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="05", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="06", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="07", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+
+#AT+GTUSBMODE=41 (0e8d:7127)  RNDIS+AT+AP(GNSS)+META+DEBUG+NPT+ADB+AP(LOG)+AP(META)(default value)
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="00", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="01", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="02", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="03", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="04", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="05", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="06", SUBSYSTEM=="tty", ENV{ID_MM_PORT_TYPE_AT_PRIMARY}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="07", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="08", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="09", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+
+GOTO="mm_fm350gl_port_types_end"
+
+LABEL="mm_fm350gl_port_types_end"
--- /dev/null
+++ b/src/plugins/fm350gl/mm-broadband-bearer-fm350gl.c
@@ -0,0 +1,472 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) GiauTM
+ * Copyright (C) PMGZED
+ * Copyright (C) ModemManager Team
+ */
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+
+#include <ModemManager.h>
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include <arpa/inet.h>
+#include <netinet/in.h>
+
+#include "mm-base-modem-at.h"
+#include "mm-log-object.h"
+
+#include "mm-broadband-bearer-fm350gl.h"
+
+// Callbacks
+static void dial_3gpp(MMBroadbandBearer *self, MMBaseModem *modem, MMPortSerialAt *primary, guint cid, GCancellable *cancellable, GAsyncReadyCallback cb, gpointer userdata);
+static MMPort *dial_3gpp_finish(MMBroadbandBearer *self, GAsyncResult *r, GError **err);
+static void get_ip_config_3gpp(MMBroadbandBearer *self, MMBroadbandModem *modem, MMPortSerialAt *primary, MMPortSerialAt *secondary, MMPort *data, guint cid, MMBearerIpFamily ip_family, GAsyncReadyCallback cb, gpointer userdata);
+static gboolean get_ip_config_3gpp_finish(MMBroadbandBearer *self, GAsyncResult *r, MMBearerIpConfig **ipv4_config, MMBearerIpConfig **ipv6_config, GError **err);
+static void disconnect_3gpp(MMBroadbandBearer *self, MMBroadbandModem *modem, MMPortSerialAt *primary, MMPortSerialAt *secondary, MMPort *data, guint cid, GAsyncReadyCallback cb, gpointer userdata);
+// Helpers
+gboolean parse_ip(const gchar *res, MMBearerIpConfig *out_ip4_config, MMBearerIpConfig *out_ip6_config, GError **err);
+GString *dectohexip(gchar *dezstring);
+
+G_DEFINE_TYPE(MMBroadbandBearerFM350GL,
+              mm_broadband_bearer_fm350gl, MM_TYPE_BROADBAND_BEARER);
+
+struct _MMBroadbandBearerFM350GLPrivate
+{
+  /*-- Common stuff --*/
+  /* Data port used when modem is connected */
+  MMPort *port;
+  /* Current connection type */
+  ConnectionType connection_type;
+  /* PPP specific */
+  MMFlowControl flow_control;
+  /*-- 3GPP specific --*/
+  /* CID of the PDP context */
+  gint profile_id;
+};
+
+typedef struct
+{
+  MMBaseModem *modem;
+  MMPortSerialAt *primary;
+  GError *saved_error;
+  MMPortSerialAt *dial_port;
+  gboolean close_dial_port_on_exit;
+} Dial3GPPContext;
+
+typedef struct
+{
+  MMBaseModem *modem;
+  MMPortSerialAt *primary;
+  MMPortSerialAt *secondary;
+  MMPort *data;
+  /* 3GPP-specific */
+  MMBearerIpFamily ip_family;
+} DetailedConnectContext;
+
+void mm_broadband_bearer_fm350gl_new(MMBroadbandModem *m,
+                                     MMBearerProperties *props,
+                                     GCancellable *cancellable,
+                                     GAsyncReadyCallback cb,
+                                     gpointer userdata)
+{
+  g_async_initable_new_async(
+      MM_TYPE_BROADBAND_BEARER_FM350GL,
+      G_PRIORITY_DEFAULT,
+      cancellable,
+      cb,
+      userdata,
+      MM_BASE_BEARER_MODEM, m,
+      MM_BASE_BEARER_CONFIG, props,
+      NULL);
+}
+
+MMBaseBearer *
+mm_broadband_bearer_fm350gl_new_finish(GAsyncResult *r,
+                                       GError **err)
+{
+  GObject *s = g_async_result_get_source_object(r);
+  GObject *b = g_async_initable_new_finish(G_ASYNC_INITABLE(s), r, err);
+  g_object_unref(s);
+  if (!b)
+  {
+    return NULL;
+  }
+  /* Only export valid bearers */
+  mm_base_bearer_export(MM_BASE_BEARER(b));
+  return MM_BASE_BEARER(b);
+}
+
+static void
+mm_broadband_bearer_fm350gl_init(MMBroadbandBearerFM350GL *s)
+{
+  /* Initialize private data */
+  s->priv = G_TYPE_INSTANCE_GET_PRIVATE(
+      s, MM_TYPE_BROADBAND_BEARER_FM350GL, MMBroadbandBearerFM350GLPrivate);
+}
+
+static void
+mm_broadband_bearer_fm350gl_class_init(MMBroadbandBearerFM350GLClass *klass)
+{
+  MMBroadbandBearerClass *c = MM_BROADBAND_BEARER_CLASS(klass);
+  c->dial_3gpp = dial_3gpp;
+  c->dial_3gpp_finish = dial_3gpp_finish;
+  c->get_ip_config_3gpp = get_ip_config_3gpp;
+  c->get_ip_config_3gpp_finish = get_ip_config_3gpp_finish;
+  c->disconnect_3gpp = disconnect_3gpp;
+}
+
+static void
+dial_3gpp_context_free(Dial3GPPContext *ctx)
+{
+  if (ctx->saved_error)
+  {
+    g_error_free(ctx->saved_error);
+  }
+  g_object_unref(ctx->primary);
+  g_object_unref(ctx->modem);
+  g_slice_free(Dial3GPPContext, ctx);
+}
+
+static void
+activate_pdp_finish(MMBaseModem *m,
+                    GAsyncResult *r,
+                    GTask *t)
+{
+  Dial3GPPContext *ctx = g_task_get_task_data(t);
+  mm_base_modem_at_command_full_finish(m, r, &ctx->saved_error);
+  // return Port for IP Configuration (ethX) to -> dial_3gpp_finish
+  MMPort *p = mm_base_modem_peek_best_data_port(m, MM_PORT_TYPE_NET);
+  g_task_return_pointer(t, g_object_ref(p), g_object_unref);
+  g_object_unref(t);
+}
+
+static void
+dial_3gpp(MMBroadbandBearer *self,
+          MMBaseModem *m,
+          MMPortSerialAt *primary,
+          guint cid,
+          GCancellable *cancellable,
+          GAsyncReadyCallback cb,
+          gpointer userdata)
+{
+  g_assert(primary != NULL);
+  Dial3GPPContext *ctx = g_slice_new0(Dial3GPPContext);
+  ctx->modem = g_object_ref(m);
+  ctx->primary = g_object_ref(primary);
+  GTask *t = g_task_new(self, cancellable, cb, userdata);
+  g_task_set_task_data(t, ctx, (GDestroyNotify)dial_3gpp_context_free);
+
+  gchar *cmd = g_strdup_printf("+CGACT=1,%d", cid);
+  mm_base_modem_at_command_full(
+      ctx->modem, ctx->primary, cmd,
+      MM_BASE_BEARER_DEFAULT_CONNECTION_TIMEOUT, FALSE,
+      FALSE, NULL, (GAsyncReadyCallback)activate_pdp_finish, t);
+  g_free(cmd);
+}
+
+static MMPort *
+dial_3gpp_finish(MMBroadbandBearer *self,
+                 GAsyncResult *r,
+                 GError **err)
+{
+  return g_task_propagate_pointer(G_TASK(r), err);
+}
+
+typedef struct
+{
+  MMBaseModem *modem;
+  MMPortSerialAt *primary;
+  guint cid;
+  MMBearerIpConfig *ipv4_config;
+  MMBearerIpConfig *ipv6_config;
+} GetIPConfig3GPPContext;
+
+static void
+get_ip_config_context_free(GetIPConfig3GPPContext *ctx)
+{
+  g_object_unref(ctx->primary);
+  g_object_unref(ctx->modem);
+  g_object_unref(ctx->ipv4_config);
+  g_object_unref(ctx->ipv6_config);
+  g_slice_free(GetIPConfig3GPPContext, ctx);
+}
+
+static void
+ip_config_dns_gw_ready(MMBaseModem *m,
+                       GAsyncResult *r,
+                       GTask *t)
+{
+  GError *err = NULL;
+  GetIPConfig3GPPContext *ctx = g_task_get_task_data(t);
+  const gchar *res = mm_base_modem_at_command_full_finish(m, r, &err);
+  if (!res || !g_str_has_prefix(res, "+CGCONTRDP"))
+  {
+    g_task_return_new_error(
+        t, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+        "missing +cgcontrdp prefix");
+    return;
+  }
+  GString *s = g_string_new(mm_strip_tag(res, "+CGCONTRDP: "));
+  g_string_replace(s, "\"", "", -1);
+
+  gchar **data = g_strsplit(s->str, ",", -1);
+  if (g_strv_length(data) < 20)
+  {
+    g_task_return_new_error(
+        t, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+        "couldn't match +cgcontrdp reply");
+    return;
+  }
+  gchar *dnsv41 = data[5];
+  gchar *dnsv42 = data[6];
+  mm_obj_info(NULL, "dns ipv4: %s %s", dnsv41, dnsv42);
+
+  GString *gstmp;
+  gstmp = dectohexip(data[28]);
+  gchar *dnsv61 = gstmp->str;
+
+  gstmp = dectohexip(data[29]);
+  gchar *dnsv62 = gstmp->str;
+
+  mm_obj_info(NULL, "dns ipv6: %s %s", dnsv61, dnsv62);
+  g_free(data);
+
+  const gchar *dnsv4[3] = {dnsv41, dnsv42, 0};
+  mm_bearer_ip_config_set_dns(ctx->ipv4_config, (const gchar **)&dnsv4);
+  const gchar *dnsv6[3] = {dnsv61, dnsv62, 0};
+  mm_bearer_ip_config_set_dns(ctx->ipv6_config, (const gchar **)&dnsv6);
+
+  MMPort *p = mm_base_modem_peek_best_data_port(m, MM_PORT_TYPE_NET);
+  MMBearerConnectResult *cr = mm_bearer_connect_result_new(p, ctx->ipv4_config, ctx->ipv6_config);
+  g_task_return_pointer(t, cr, (GDestroyNotify)mm_bearer_connect_result_unref);
+  g_object_unref(t);
+}
+
+static void
+ip_config_ipaddress_ready(MMBaseModem *m,
+                          GAsyncResult *r,
+                          GTask *t)
+{
+  GError *err = NULL;
+  const gchar *res = mm_base_modem_at_command_full_finish(m, r, &err);
+  if (err)
+  {
+    mm_obj_dbg(NULL, "AT+CGPADDR failed no IP data: %s", err->message);
+    g_task_return_error(t, err);
+    return;
+  }
+  GetIPConfig3GPPContext *ctx = g_task_get_task_data(t);
+  ctx->ipv4_config = mm_bearer_ip_config_new();
+  ctx->ipv6_config = mm_bearer_ip_config_new();
+  if (!parse_ip(res, ctx->ipv4_config, ctx->ipv6_config, &err))
+  {
+    g_task_return_error(t, err);
+    return;
+  }
+  gchar *cmd = g_strdup_printf("AT+CGCONTRDP");
+  mm_base_modem_at_command_full(
+      MM_BASE_MODEM(m), ctx->primary, cmd, 3, FALSE,
+      FALSE, NULL, (GAsyncReadyCallback)ip_config_dns_gw_ready, t);
+  g_free(cmd);
+}
+
+static void
+get_ip_config_3gpp(MMBroadbandBearer *self,
+                   MMBroadbandModem *modem,
+                   MMPortSerialAt *primary,
+                   MMPortSerialAt *secondary,
+                   MMPort *data,
+                   guint cid,
+                   MMBearerIpFamily ip_family,
+                   GAsyncReadyCallback cb,
+                   gpointer userdata)
+{
+  g_assert(primary != NULL);
+  mm_obj_info(NULL, "3gpp Dataport:: %s", mm_port_get_device(data));
+  GetIPConfig3GPPContext *ctx = g_slice_new0(GetIPConfig3GPPContext);
+  ctx->modem = MM_BASE_MODEM(g_object_ref(modem));
+  ctx->primary = g_object_ref(primary);
+  ctx->cid = cid;
+  GTask *t = g_task_new(self, NULL, cb, userdata);
+  g_task_set_task_data(t, ctx, (GDestroyNotify)get_ip_config_context_free);
+
+  gchar *cmd = g_strdup_printf("AT+CGPADDR=%d", cid);
+  mm_base_modem_at_command_full(
+      MM_BASE_MODEM(modem), primary, cmd, 3, FALSE,
+      FALSE, NULL, (GAsyncReadyCallback)ip_config_ipaddress_ready, t);
+  g_free(cmd);
+}
+
+static gboolean
+get_ip_config_3gpp_finish(MMBroadbandBearer *self,
+                          GAsyncResult *r,
+                          MMBearerIpConfig **ipv4_config,
+                          MMBearerIpConfig **ipv6_config,
+                          GError **err)
+{
+  MMBearerConnectResult *c = g_task_propagate_pointer(G_TASK(r), err);
+  if (!c)
+  {
+    return FALSE;
+  }
+  MMBearerIpConfig *ipv4 = mm_bearer_connect_result_peek_ipv4_config(c);
+  MMBearerIpConfig *ipv6 = mm_bearer_connect_result_peek_ipv6_config(c);
+  g_assert(ipv4 || ipv6);
+  if (ipv4_config && ipv4)
+  {
+    *ipv4_config = g_object_ref(ipv4);
+  }
+  if (ipv6_config && ipv6)
+  {
+    *ipv6_config = g_object_ref(ipv6);
+  }
+  mm_bearer_connect_result_unref(c);
+  return TRUE;
+}
+
+static void
+cgact_ready(MMBaseModem *m,
+            GAsyncResult *r,
+            GTask *t)
+{
+  GError *err = NULL;
+  mm_base_modem_at_command_full_finish(m, r, &err);
+  if (err)
+  {
+    MMBroadbandBearer *s = g_task_get_source_object(t);
+    mm_obj_dbg(s, "PDP context deactivation failed (not fatal): %s", err->message);
+  }
+  g_task_return_boolean(t, TRUE);
+  g_object_unref(t);
+}
+
+static void
+disconnect_3gpp(MMBroadbandBearer *self,
+                MMBroadbandModem *m,
+                MMPortSerialAt *primary,
+                MMPortSerialAt *secondary,
+                MMPort *data,
+                guint cid,
+                GAsyncReadyCallback cb,
+                gpointer userdata)
+{
+  g_assert(primary != NULL);
+  gchar *cmd = g_strdup_printf("+CGACT=0,%d", cid);
+  GTask *t = g_task_new(self, NULL, cb, userdata);
+  mm_obj_dbg(self, "sending PDP context deactivation in primary port...");
+  mm_base_modem_at_command_full(
+      MM_BASE_MODEM(g_object_ref(m)), primary, cmd, 45, FALSE,
+      FALSE, NULL, (GAsyncReadyCallback)cgact_ready, t);
+  g_free(cmd);
+}
+
+GString *
+dectohexip(gchar *dec)
+{
+  GString *output = g_string_new("");
+  GString *dstr = g_string_new(dec);
+  gchar **parts = g_strsplit(dstr->str, ".", -1);
+  int i, c = g_strv_length(parts);
+  for (i = 0; i < c; i++)
+  {
+    if (i == 0)
+    {
+      g_string_append(output, g_strdup_printf("%02x", atoi(parts[i])));
+    }
+    else
+    {
+      if (i % 2 == 0)
+      {
+        g_string_append(output, ":");
+      }
+      g_string_append(output, g_strdup_printf("%02x", atoi(parts[i])));
+    }
+  }
+  return output;
+}
+
+gboolean
+parse_ip(const gchar *res,
+         MMBearerIpConfig *outv4,
+         MMBearerIpConfig *outv6,
+         GError **err)
+{
+  g_return_val_if_fail(outv4, FALSE);
+  g_return_val_if_fail(outv6, FALSE);
+  if (!res || !g_str_has_prefix(res, "+CGPADDR"))
+  {
+    g_set_error(err, MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "missing +CGPADDR prefix");
+    return FALSE;
+  }
+  GString *s = g_string_new(mm_strip_tag(res, "+CGPADDR: "));
+  g_string_replace(s, "\"", "", -1);
+  gchar **data = g_strsplit(s->str, ",", -1);
+  int c = g_strv_length(data);
+  if (c != 3)
+  {
+    g_set_error_literal(err, MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "couldn't match +CGPADDR reply");
+    return TRUE;
+  }
+  gchar *ipv4 = NULL;
+  gchar *ipv6 = NULL;
+  gchar *ip1 = data[1];
+  gchar *ip2 = data[2];
+  g_free(data);
+
+  mm_bearer_ip_config_set_method(outv4, MM_BEARER_IP_METHOD_UNKNOWN);
+  mm_bearer_ip_config_set_method(outv6, MM_BEARER_IP_METHOD_UNKNOWN);
+
+  gchar **data1 = g_strsplit(ip1, ".", -1);
+  c = g_strv_length(data1);
+  g_free(data1);
+  if (c < 5 && c > 1)
+  {
+    ipv4 = ip1;
+    mm_bearer_ip_config_set_method(outv4, MM_BEARER_IP_METHOD_STATIC);
+    mm_bearer_ip_config_set_address(outv4, ipv4);
+    mm_bearer_ip_config_set_prefix(outv4, 32);
+    mm_bearer_ip_config_set_gateway(outv4, ipv4);
+  }
+  if (c > 5)
+  {
+    ipv6 = ip1;
+    mm_bearer_ip_config_set_method(outv6, MM_BEARER_IP_METHOD_DHCP);
+  }
+
+  gchar **data2 = g_strsplit(ip2, ".", -1);
+  c = g_strv_length(data2);
+  g_free(data2);
+  if (c < 5 && c > 1)
+  {
+    ipv4 = ip2;
+    mm_bearer_ip_config_set_method(outv4, MM_BEARER_IP_METHOD_STATIC);
+    mm_bearer_ip_config_set_address(outv4, ipv4);
+    mm_bearer_ip_config_set_prefix(outv4, 32);
+    mm_bearer_ip_config_set_gateway(outv4, ipv4);
+  }
+  if (c > 5)
+  {
+    mm_bearer_ip_config_set_method(outv6, MM_BEARER_IP_METHOD_DHCP);
+    ipv6 = dectohexip(ip2)->str;
+  }
+  mm_obj_info(NULL, "ipv4: %s", ipv4);
+  mm_obj_info(NULL, "ipv6: %s", ipv6);
+  return TRUE;
+}
--- /dev/null
+++ b/src/plugins/fm350gl/mm-broadband-bearer-fm350gl.h
@@ -0,0 +1,76 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ */
+
+#ifndef MM_BROADBAND_BEARER_FM350GL_H
+#define MM_BROADBAND_BEARER_FM350GL_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include "mm-broadband-bearer.h"
+#include "mm-broadband-modem-fm350gl.h"
+
+#define MM_TYPE_BROADBAND_BEARER_FM350GL (mm_broadband_bearer_fm350gl_get_type())
+#define MM_BROADBAND_BEARER_FM350GL(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), MM_TYPE_BROADBAND_BEARER_FM350GL, MMBroadbandBearerFM350GL))
+#define MM_BROADBAND_BEARER_FM350GL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), MM_TYPE_BROADBAND_BEARER_FM350GL, MMBroadbandBearerFM350GLClass))
+#define MM_IS_BROADBAND_BEARER_FM350GL(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), MM_TYPE_BROADBAND_BEARER_FM350GL))
+#define MM_IS_BROADBAND_BEARER_FM350GL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), MM_TYPE_BROADBAND_BEARER_FM350GL))
+#define MM_BROADBAND_BEARER_FM350GL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS((obj), MM_TYPE_BROADBAND_BEARER_FM350GL, MMBroadbandBearerFM350GLClass))
+
+GType mm_broadband_bearer_fm350gl_get_type(void);
+
+typedef struct _MMBroadbandBearerFM350GL MMBroadbandBearerFM350GL;
+typedef struct _MMBroadbandBearerFM350GLClass MMBroadbandBearerFM350GLClass;
+typedef struct _MMBroadbandBearerFM350GLPrivate MMBroadbandBearerFM350GLPrivate;
+
+typedef enum
+{
+  CONNECTION_TYPE_NONE,
+  CONNECTION_TYPE_3GPP,
+  CONNECTION_TYPE_CDMA,
+} ConnectionType;
+
+struct _MMBroadbandBearerFM350GL
+{
+  /*-- Common stuff --*/
+  /* Data port used when modem is connected */
+  MMPort *port;
+  /* Current connection type */
+  ConnectionType connection_type;
+  /* PPP specific */
+  //    MMFlowControl flow_control;
+  /*-- 3GPP specific --*/
+  /* CID of the PDP context */
+  gint profile_id;
+  MMBroadbandBearer parent;
+  MMBroadbandBearerFM350GLPrivate *priv;
+};
+
+struct _MMBroadbandBearerFM350GLClass
+{
+  MMBroadbandBearerClass parent;
+};
+
+void mm_broadband_bearer_fm350gl_new(MMBroadbandModem *modem,
+                                     MMBearerProperties *bearer_properties,
+                                     GCancellable *cancellable,
+                                     GAsyncReadyCallback cb,
+                                     gpointer userdata);
+
+MMBaseBearer *
+mm_broadband_bearer_fm350gl_new_finish(GAsyncResult *r,
+                                       GError **err);
+
+#endif /* MM_BROADBAND_BEARER_FM350GL_H */
--- /dev/null
+++ b/src/plugins/fm350gl/mm-broadband-modem-fm350gl.c
@@ -0,0 +1,757 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) GiauTM
+ * Copyright (C) PMGZED
+ * Copyright (C) ModemManager Team
+ */
+
+#include <config.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <ctype.h>
+
+#include "ModemManager.h"
+#include "mm-base-modem-at.h"
+#include "mm-common-helpers.h"
+#include "mm-errors-types.h"
+#include "mm-iface-modem-3gpp-profile-manager.h"
+#include "mm-iface-modem-3gpp.h"
+#include "mm-iface-modem-time.h"
+#include "mm-iface-modem.h"
+#include "mm-log-object.h"
+#include "mm-log.h"
+#include "mm-modem-helpers.h"
+
+#include "mm-broadband-bearer-fm350gl.h"
+#include "mm-broadband-modem-fm350gl.h"
+
+// Callbacks
+static void modem_create_bearer(MMIfaceModem *m, MMBearerProperties *properties, GAsyncReadyCallback cb, gpointer userdata);
+static MMBaseBearer *modem_create_bearer_finish(MMIfaceModem *m, GAsyncResult *r, GError **err);
+static void modem_load_current_bands(MMIfaceModem *m, GAsyncReadyCallback cb, gpointer userdata);
+static GArray *modem_load_current_bands_finish(MMIfaceModem *m, GAsyncResult *r, GError **err);
+static void modem_load_current_modes(MMIfaceModem *m, GAsyncReadyCallback cb, gpointer userdata);
+static gboolean modem_load_current_modes_finish(MMIfaceModem *m, GAsyncResult *r, MMModemMode *allowed, MMModemMode *preferred, GError **err);
+static void modem_load_signal_quality(MMIfaceModem *m, GAsyncReadyCallback cb, gpointer userdata); // std also works with this one is queried with +CSQ
+static guint modem_load_signal_quality_finish(MMIfaceModem *m, GAsyncResult *r, GError **err);
+static void modem_load_supported_bands(MMIfaceModem *m, GAsyncReadyCallback cb, gpointer userdata);
+static GArray *modem_load_supported_bands_finish(MMIfaceModem *m, GAsyncResult *r, GError **err);
+static void modem_load_supported_modes(MMIfaceModem *m, GAsyncReadyCallback cb, gpointer userdata);
+static GArray *modem_load_supported_modes_finish(MMIfaceModem *m, GAsyncResult *r, GError **err);
+static void modem_set_current_bands(MMIfaceModem *m, GArray *bands_array, GAsyncReadyCallback cb, gpointer userdata);
+static gboolean modem_set_current_bands_finish(MMIfaceModem *m, GAsyncResult *r, GError **err);
+static void modem_set_current_modes(MMIfaceModem *m, MMModemMode allowed, MMModemMode preferred, GAsyncReadyCallback cb, gpointer userdata);
+static gboolean modem_set_current_modes_finish(MMIfaceModem *m, GAsyncResult *r, GError **err);
+static void enabling_modem_init(MMBroadbandModem *m, GAsyncReadyCallback cb, gpointer userdata);
+static void modem_3gpp_profile_manager_check_format(MMIfaceModem3gppProfileManagerInterface *pm, MMBearerIpFamily ip_type, GAsyncReadyCallback cb, gpointer userdata);
+
+static void iface_modem_init(MMIfaceModemInterface *pm);
+static void iface_modem_3gpp_profile_manager_init(MMIfaceModem3gppProfileManagerInterface *pm);
+
+G_DEFINE_TYPE_EXTENDED(
+    MMBroadbandModemFM350GL, mm_broadband_modem_fm350gl,
+    MM_TYPE_BROADBAND_MODEM, 0,
+    G_IMPLEMENT_INTERFACE(MM_TYPE_IFACE_MODEM, iface_modem_init)
+        G_IMPLEMENT_INTERFACE(MM_TYPE_IFACE_MODEM_3GPP_PROFILE_MANAGER, iface_modem_3gpp_profile_manager_init));
+
+MMBroadbandModemFM350GL *
+mm_broadband_modem_FM350GL_new(const gchar *device,
+                               const gchar *physdev,
+                               const gchar **drivers,
+                               const gchar *plugin,
+                               guint16 vid,
+                               guint16 pid)
+{
+  return g_object_new(
+      MM_TYPE_BROADBAND_MODEM_FM350GL,
+      MM_BASE_MODEM_DEVICE, device,
+      MM_BASE_MODEM_PHYSDEV, physdev,
+      MM_BASE_MODEM_DRIVERS, drivers,
+      MM_BASE_MODEM_PLUGIN, plugin,
+      MM_BASE_MODEM_VENDOR_ID, vid,
+      MM_BASE_MODEM_PRODUCT_ID, pid,
+      MM_BASE_MODEM_DATA_NET_SUPPORTED, TRUE,
+      MM_BASE_MODEM_DATA_TTY_SUPPORTED, FALSE,
+      NULL);
+}
+
+static void
+iface_modem_init(MMIfaceModemInterface *m)
+{
+  m->create_bearer = modem_create_bearer;
+  m->create_bearer_finish = modem_create_bearer_finish;
+  m->load_current_bands = modem_load_current_bands;
+  m->load_current_bands_finish = modem_load_current_bands_finish;
+  m->load_current_modes = modem_load_current_modes;
+  m->load_current_modes_finish = modem_load_current_modes_finish;
+  m->load_signal_quality = modem_load_signal_quality;
+  m->load_signal_quality_finish = modem_load_signal_quality_finish;
+  m->load_supported_bands = modem_load_supported_bands;
+  m->load_supported_bands_finish = modem_load_supported_bands_finish;
+  m->load_supported_modes = modem_load_supported_modes;
+  m->load_supported_modes_finish = modem_load_supported_modes_finish;
+  m->set_current_bands = modem_set_current_bands;
+  m->set_current_bands_finish = modem_set_current_bands_finish;
+  m->set_current_modes = modem_set_current_modes;
+  m->set_current_modes_finish = modem_set_current_modes_finish;
+}
+
+static void
+broadband_bearer_fm350gl_new_ready(GObject *s,
+                                   GAsyncResult *r,
+                                   GTask *t)
+{
+  GError *err = NULL;
+  MMBaseBearer *bearer = mm_broadband_bearer_fm350gl_new_finish(r, &err);
+  if (!bearer)
+  {
+    g_task_return_error(t, err);
+    g_object_unref(t);
+    return;
+  }
+  g_task_return_pointer(t, bearer, g_object_unref);
+  g_object_unref(t);
+}
+
+static void
+modem_create_bearer(MMIfaceModem *m,
+                    MMBearerProperties *props,
+                    GAsyncReadyCallback cb,
+                    gpointer userdata)
+{
+  GTask *t = g_task_new(m, NULL, cb, userdata);
+  mm_broadband_bearer_fm350gl_new(
+      MM_BROADBAND_MODEM(m), props, NULL,
+      (GAsyncReadyCallback)broadband_bearer_fm350gl_new_ready, t);
+}
+
+static MMBaseBearer *
+modem_create_bearer_finish(MMIfaceModem *m,
+                           GAsyncResult *r,
+                           GError **err)
+{
+  return g_task_propagate_pointer(G_TASK(r), err);
+}
+
+static void
+load_current_bands_done(MMIfaceModem *m,
+                        GAsyncResult *r,
+                        GTask *t)
+{
+  GError *err = NULL;
+  const gchar *res = mm_base_modem_at_command_finish(MM_BASE_MODEM(m), r, &err);
+  if (!res)
+  {
+    g_task_return_error(t, err);
+    g_object_unref(t);
+    return;
+  }
+  GString *s = g_string_new(mm_strip_tag(res, "+GTACT: "));
+  gchar **parts = g_strsplit(s->str, ",", -1);
+  int c = g_strv_length(parts);
+  if (c < 4)
+  {
+    g_task_return_new_error(t,
+                            MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+                            "failed to parse supported bands response");
+    g_object_unref(t);
+    return;
+  }
+  GArray *bands = g_array_new(FALSE, FALSE, sizeof(MMModemBand));
+  int i, count = g_strv_length(parts);
+  for (i = 3; i < count; i++)
+  {
+    int tmp = atoi(parts[i]);
+    if (tmp >= 100 && tmp < 200)
+    {
+      tmp -= 100 - 30;
+    }
+    if (tmp >= 500 && tmp < 600)
+    {
+      tmp -= 500 - 300;
+    }
+    if (tmp >= 5000 && tmp < 6000)
+    {
+      tmp -= 5000 - 300;
+    }
+    bands = g_array_append_val(bands, tmp);
+  }
+  g_task_return_pointer(t, bands, (GDestroyNotify)g_array_unref);
+  g_object_unref(t);
+}
+
+static void
+modem_load_current_bands(MMIfaceModem *m,
+                         GAsyncReadyCallback cb,
+                         gpointer userdata)
+{
+  GTask *t = g_task_new(m, NULL, cb, userdata);
+  mm_base_modem_at_command(
+      MM_BASE_MODEM(m), "+GTACT?", 3, FALSE,
+      (GAsyncReadyCallback)load_current_bands_done, t);
+}
+
+static GArray *
+modem_load_current_bands_finish(MMIfaceModem *m,
+                                GAsyncResult *r,
+                                GError **err)
+{
+  return g_task_propagate_pointer(G_TASK(r), err);
+}
+
+static void
+modem_load_current_modes(MMIfaceModem *m,
+                         GAsyncReadyCallback cb,
+                         gpointer userdata)
+{
+  mm_base_modem_at_command(
+      MM_BASE_MODEM(m), "AT+GTACT?", 3, FALSE, cb, userdata);
+}
+
+static gboolean
+modem_load_current_modes_finish(MMIfaceModem *m,
+                                GAsyncResult *r,
+                                MMModemMode *allowed,
+                                MMModemMode *preferred,
+                                GError **err)
+{
+  *allowed = MM_MODEM_MODE_5G | MM_MODEM_MODE_4G | MM_MODEM_MODE_3G;
+  *preferred = MM_MODEM_MODE_NONE;
+  g_autoptr(GError) errorcf = NULL;
+  const gchar *res = mm_base_modem_at_command_full_finish(
+      MM_BASE_MODEM(m), r, &errorcf);
+  if (!res)
+  {
+    return TRUE;
+  }
+  GString *s = g_string_new(mm_strip_tag(res, "+GTACT: "));
+  gchar **data = g_strsplit(s->str, ",", -1);
+  int c = g_strv_length(data);
+  if (c < 2)
+  {
+    return TRUE;
+  }
+  if (g_ascii_strcasecmp(data[0], "1") == 0)
+  {
+    *allowed = MM_MODEM_MODE_3G;
+  }
+  if (g_ascii_strcasecmp(data[0], "2") == 0)
+  {
+    *allowed = MM_MODEM_MODE_4G;
+  }
+  if (g_ascii_strcasecmp(data[0], "4") == 0)
+  {
+    *allowed = MM_MODEM_MODE_3G | MM_MODEM_MODE_4G;
+  }
+  if (g_ascii_strcasecmp(data[0], "14") == 0)
+  {
+    *allowed = MM_MODEM_MODE_5G;
+  }
+  if (g_ascii_strcasecmp(data[0], "16") == 0)
+  {
+    *allowed = MM_MODEM_MODE_3G | MM_MODEM_MODE_5G;
+  }
+  if (g_ascii_strcasecmp(data[0], "17") == 0)
+  {
+    *allowed = MM_MODEM_MODE_4G | MM_MODEM_MODE_5G;
+  }
+  if (g_ascii_strcasecmp(data[0], "20") == 0)
+  {
+    *allowed = MM_MODEM_MODE_3G | MM_MODEM_MODE_4G | MM_MODEM_MODE_5G;
+  }
+  if (g_ascii_strcasecmp(data[1], "2") == 0)
+  {
+    *preferred = MM_MODEM_MODE_3G;
+  }
+  if (g_ascii_strcasecmp(data[1], "3") == 0)
+  {
+    *preferred = MM_MODEM_MODE_4G;
+  }
+  if (g_ascii_strcasecmp(data[1], "6") == 0)
+  {
+    *preferred = MM_MODEM_MODE_5G;
+  }
+  return TRUE;
+}
+
+static void
+modem_load_signal_quality(MMIfaceModem *m,
+                          GAsyncReadyCallback cb,
+                          gpointer userdata)
+{
+  mm_base_modem_at_command(
+      MM_BASE_MODEM(m), "+CSQ", 3, FALSE, cb, userdata);
+}
+
+static guint
+modem_load_signal_quality_finish(MMIfaceModem *m,
+                                 GAsyncResult *r,
+                                 GError **err)
+{
+  const gchar *res = mm_base_modem_at_command_finish(MM_BASE_MODEM(m), r, err);
+  if (!res || !res[0])
+  {
+    return 0;
+  }
+  const gchar *p = mm_strip_tag(res, "+CSQ:");
+  gint quality = 0, ber = 0;
+  if (sscanf(p, "%d, %d", &quality, &ber))
+  {
+    if (quality != 99)
+    {
+      quality = CLAMP(quality, 0, 31) * 100 / 31;
+    }
+    else
+    {
+      quality = 0;
+    }
+    return quality;
+  }
+  return 0;
+}
+
+static void
+load_supported_bands_done(MMIfaceModem *m,
+                          GAsyncResult *r,
+                          GTask *t)
+{
+  GError *err = NULL;
+  const gchar *res = mm_base_modem_at_command_finish(MM_BASE_MODEM(m), r, &err);
+  if (!res)
+  {
+    g_task_return_error(t, err);
+    g_object_unref(t);
+    return;
+  }
+  GString *s = g_string_new(mm_strip_tag(res, "+GTACT: "));
+  g_string_replace(s, ")", "", -1);
+  g_string_replace(s, "(", "|", -1);
+  gchar **parts = g_strsplit(s->str, "|", -1);
+  int c = g_strv_length(parts);
+  if (c != 10)
+  {
+    g_task_return_new_error(
+        t, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+        "Failed to parse supported bands response");
+    g_object_unref(t);
+    return;
+  }
+  GArray *bands = g_array_new(FALSE, FALSE, sizeof(MMModemBand));
+  gchar **umtsbands = g_strsplit(parts[5], ",", -1);
+  int i, cumts = g_strv_length(umtsbands) - 1;
+  for (i = 0; i < cumts; i++)
+  {
+    int tmp = atoi(umtsbands[i]);
+    bands = g_array_append_val(bands, tmp);
+  }
+
+  GString *stmp;
+  gchar **lteband = g_strsplit(parts[6], ",", -1);
+  int clte = g_strv_length(lteband) - 1;
+  for (i = 0; i < clte; i++)
+  {
+    stmp = g_string_new(lteband[i]);
+    g_string_erase(stmp, 0, 1);
+    int tmp = atoi(stmp->str) + 30;
+    bands = g_array_append_val(bands, tmp);
+  }
+
+  gchar **nrband = g_strsplit(parts[9], ",", -1);
+  int cnr = g_strv_length(nrband);
+  for (i = 0; i < cnr; i++)
+  {
+    stmp = g_string_new(nrband[i]);
+    g_string_erase(stmp, 0, 1);
+    int tmp = atoi(stmp->str) + 300;
+    bands = g_array_append_val(bands, tmp);
+  }
+  g_task_return_pointer(t, bands, (GDestroyNotify)g_array_unref);
+  g_object_unref(t);
+}
+
+static void
+modem_load_supported_bands(MMIfaceModem *m,
+                           GAsyncReadyCallback cb,
+                           gpointer userdata)
+{
+  GTask *t = g_task_new(m, NULL, cb, userdata);
+  mm_base_modem_at_command(
+      MM_BASE_MODEM(m), "+GTACT=?", 3, FALSE,
+      (GAsyncReadyCallback)load_supported_bands_done, t);
+}
+
+static GArray *
+modem_load_supported_bands_finish(MMIfaceModem *m,
+                                  GAsyncResult *r,
+                                  GError **err)
+{
+  return g_task_propagate_pointer(G_TASK(r), err);
+}
+
+static void
+modem_load_supported_modes(MMIfaceModem *m,
+                           GAsyncReadyCallback cb,
+                           gpointer userdata)
+{
+  GArray *combinations = g_array_sized_new(
+      FALSE, FALSE, sizeof(MMModemModeCombination), 4);
+  MMModemModeCombination mode;
+  mode.allowed = (MM_MODEM_MODE_3G);
+  mode.preferred = MM_MODEM_MODE_NONE;
+  g_array_append_val(combinations, mode);
+  mode.allowed = (MM_MODEM_MODE_4G);
+  mode.preferred = MM_MODEM_MODE_NONE;
+  g_array_append_val(combinations, mode);
+  mode.allowed = (MM_MODEM_MODE_5G);
+  mode.preferred = MM_MODEM_MODE_NONE;
+  g_array_append_val(combinations, mode);
+  mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G);
+  mode.preferred = MM_MODEM_MODE_3G;
+  g_array_append_val(combinations, mode);
+  mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G);
+  mode.preferred = MM_MODEM_MODE_4G;
+  g_array_append_val(combinations, mode);
+  mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_5G);
+  mode.preferred = MM_MODEM_MODE_3G;
+  g_array_append_val(combinations, mode);
+  mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_5G);
+  mode.preferred = MM_MODEM_MODE_5G;
+  g_array_append_val(combinations, mode);
+  mode.allowed = (MM_MODEM_MODE_4G | MM_MODEM_MODE_5G);
+  mode.preferred = MM_MODEM_MODE_4G;
+  g_array_append_val(combinations, mode);
+  mode.allowed = (MM_MODEM_MODE_4G | MM_MODEM_MODE_5G);
+  mode.preferred = MM_MODEM_MODE_5G;
+  g_array_append_val(combinations, mode);
+  mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G | MM_MODEM_MODE_5G);
+  mode.preferred = MM_MODEM_MODE_3G;
+  g_array_append_val(combinations, mode);
+  mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G | MM_MODEM_MODE_5G);
+  mode.preferred = MM_MODEM_MODE_4G;
+  g_array_append_val(combinations, mode);
+  mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G | MM_MODEM_MODE_5G);
+  mode.preferred = MM_MODEM_MODE_5G;
+  g_array_append_val(combinations, mode);
+
+  GTask *t = g_task_new(m, NULL, cb, userdata);
+  g_task_return_pointer(t, combinations, (GDestroyNotify)g_array_unref);
+}
+
+static GArray *
+modem_load_supported_modes_finish(MMIfaceModem *m,
+                                  GAsyncResult *r,
+                                  GError **err)
+{
+  return g_task_propagate_pointer(G_TASK(r), err);
+}
+
+static void
+set_current_bands_set_finish(MMBaseModem *bm,
+                             GAsyncResult *r,
+                             GTask *t)
+{
+  GError *err = NULL;
+  const gchar *res = mm_base_modem_at_command_finish(bm, r, &err);
+  if (!res)
+  {
+    g_task_return_error(t, err);
+    g_object_unref(t);
+    return;
+  }
+  g_task_return_boolean(t, TRUE);
+  g_object_unref(t);
+}
+
+static void
+set_current_bands_get_current_rats(MMBaseModem *bm,
+                                   GAsyncResult *r,
+                                   GTask *t)
+{
+  GError *err = NULL;
+  const gchar *res = mm_base_modem_at_command_finish(bm, r, &err);
+  if (!res)
+  {
+    g_task_return_error(t, err);
+    g_object_unref(t);
+    return;
+  }
+  GString *s = g_string_new(mm_strip_tag(res, "+GTACT: "));
+  gchar **parts = g_strsplit(s->str, ",", -1);
+  int c = g_strv_length(parts);
+  if (c < 3)
+  {
+    g_task_return_new_error(
+        t, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+        "failed to parse Rats response");
+    g_object_unref(t);
+    return;
+  }
+  GString *cmd = g_string_new("AT+GTACT=");
+  g_string_append(cmd, parts[0]);
+  g_string_append(cmd, ",");
+  g_string_append(cmd, parts[1]);
+  g_string_append(cmd, ",");
+  g_string_append(cmd, parts[2]);
+  GArray *ctx = g_task_get_task_data(t);
+  int i, j = ctx->len;
+  for (i = 0; i < j; i++)
+  {
+    int b = g_array_index(ctx, MMModemBand, i);
+    if (b > 0 && b < 30)
+    {
+      g_string_append(cmd, ",");
+      g_string_append(cmd, g_strdup_printf("%i", b));
+      continue;
+    }
+    if (b > 30 && b < 300)
+    {
+      b = b - 30 + 100;
+      g_string_append(cmd, ",");
+      g_string_append(cmd, g_strdup_printf("%i", b));
+      continue;
+    }
+    if (b > 30 && b < 599)
+    {
+      b -= 300;
+      if (b > 0 && b < 10)
+      {
+        b += 500;
+      }
+      else
+      {
+        b += 5000;
+      }
+      g_string_append(cmd, ",");
+      g_string_append(cmd, g_strdup_printf("%i", b));
+      continue;
+    }
+  }
+  mm_base_modem_at_command(
+      MM_BASE_MODEM(bm), cmd->str, 3, TRUE,
+      (GAsyncReadyCallback)set_current_bands_set_finish, t);
+  return;
+}
+
+static void
+set_current_bands_context_free(GArray *ctx)
+{
+}
+
+static void
+modem_set_current_bands(MMIfaceModem *m,
+                        GArray *bands,
+                        GAsyncReadyCallback cb,
+                        gpointer userdata)
+{
+  GTask *t = g_task_new(m, NULL, cb, userdata);
+  g_task_set_task_data(t, bands, (GDestroyNotify)set_current_bands_context_free);
+  mm_base_modem_at_command(
+      MM_BASE_MODEM(m), "AT+GTACT?", 3, TRUE,
+      (GAsyncReadyCallback)set_current_bands_get_current_rats, t);
+}
+
+static gboolean
+modem_set_current_bands_finish(MMIfaceModem *m,
+                               GAsyncResult *r,
+                               GError **err)
+{
+  return g_task_propagate_boolean(G_TASK(r), err);
+}
+
+static void
+modem_set_current_modes(MMIfaceModem *m,
+                        MMModemMode allowed,
+                        MMModemMode preferred,
+                        GAsyncReadyCallback cb,
+                        gpointer userdata)
+{
+  int rat = 20;
+  if (allowed == (MM_MODEM_MODE_3G))
+  {
+    rat = 1;
+  }
+  if (allowed == (MM_MODEM_MODE_4G))
+  {
+    rat = 2;
+  }
+  if (allowed == (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G))
+  {
+    rat = 4;
+  }
+  if (allowed == (MM_MODEM_MODE_5G))
+  {
+    rat = 14;
+  }
+  if (allowed == (MM_MODEM_MODE_5G | MM_MODEM_MODE_3G))
+  {
+    rat = 16;
+  }
+  if (allowed == (MM_MODEM_MODE_4G | MM_MODEM_MODE_5G))
+  {
+    rat = 17;
+  }
+  if (allowed == (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G | MM_MODEM_MODE_5G))
+  {
+    rat = 20;
+  }
+
+  int pref = 0;
+  if (preferred == MM_MODEM_MODE_3G)
+  {
+    pref = 2;
+  }
+  if (preferred == MM_MODEM_MODE_4G)
+  {
+    pref = 3;
+  }
+  if (preferred == MM_MODEM_MODE_5G)
+  {
+    pref = 6;
+  }
+
+  gchar *cmd;
+  if (pref == 0)
+  {
+    cmd = g_strdup_printf("+GTACT=%d", rat);
+  }
+  else
+  {
+    cmd = g_strdup_printf("+GTACT=%d,%d", rat, pref);
+  }
+  mm_base_modem_at_command(MM_BASE_MODEM(m), cmd, 3, FALSE, cb, userdata);
+  g_free(cmd);
+}
+
+static gboolean
+modem_set_current_modes_finish(MMIfaceModem *m,
+                               GAsyncResult *r,
+                               GError **err)
+{
+  return g_task_propagate_boolean(G_TASK(r), err);
+}
+
+static void
+iface_modem_3gpp_profile_manager_init(MMIfaceModem3gppProfileManagerInterface *pm)
+{
+  pm->check_format = modem_3gpp_profile_manager_check_format;
+}
+
+typedef struct
+{
+  MMBearerIpFamily ip_type;
+  guint min_profile_id;
+  guint max_profile_id;
+} CheckFormatContext;
+
+static void
+check_format_context_free(CheckFormatContext *ctx)
+{
+  g_slice_free(CheckFormatContext, ctx);
+}
+
+static void
+check_format_cgdcont_test_ready(MMBaseModem *m,
+                                GAsyncResult *r,
+                                GTask *t)
+{
+  CheckFormatContext *ctx = g_task_get_task_data(t);
+  g_autoptr(GError) err = NULL;
+  gboolean checked = FALSE;
+  const gchar *res = mm_base_modem_at_command_full_finish(m, r, &err);
+  if (!res)
+  {
+    mm_obj_dbg(m, "failed checking context definition format: %s", err->message);
+  }
+  else
+  {
+    GList *fmt = mm_3gpp_parse_cgdcont_test_response(res, m, &err);
+    if (err)
+    {
+      mm_obj_dbg(m, "error parsing +CGDCONT test response: %s", err->message);
+    }
+    else
+    {
+      checked = mm_3gpp_pdp_context_format_list_find_range(
+          fmt, ctx->ip_type, &ctx->min_profile_id, &ctx->max_profile_id);
+    }
+    mm_3gpp_pdp_context_format_list_free(fmt);
+  }
+  if (checked)
+  {
+    ctx->min_profile_id = 1;
+    ctx->max_profile_id = 1;
+    g_autofree gchar *family = mm_bearer_ip_family_build_string_from_mask(ctx->ip_type);
+    mm_obj_dbg(m, "+CGDCONT format details for PDP type '%s': minimum %d, maximum %d",
+               family, ctx->min_profile_id, ctx->max_profile_id);
+  }
+  else
+  {
+    ctx->min_profile_id = 1;
+    ctx->max_profile_id = G_MAXINT - 1;
+    g_autofree gchar *family = mm_bearer_ip_family_build_string_from_mask(ctx->ip_type);
+    mm_obj_dbg(m, "unknown +CGDCONT format details for PDP type '%s', using defaults: minimum %d, maximum %d",
+               family, ctx->min_profile_id, ctx->max_profile_id);
+  }
+  g_task_return_boolean(t, TRUE);
+  g_object_unref(t);
+}
+
+static void
+modem_3gpp_profile_manager_check_format(MMIfaceModem3gppProfileManagerInterface *pm,
+                                        MMBearerIpFamily ip_type,
+                                        GAsyncReadyCallback cb,
+                                        gpointer userdata)
+{
+  CheckFormatContext *ctx = g_slice_new0(CheckFormatContext);
+  ctx->ip_type = ip_type;
+  GTask *t = g_task_new(pm, NULL, cb, userdata);
+  g_task_set_task_data(t, ctx, (GDestroyNotify)check_format_context_free);
+  mm_base_modem_at_command(
+      MM_BASE_MODEM(pm), "+CGDCONT=?", 3, TRUE,
+      (GAsyncReadyCallback)check_format_cgdcont_test_ready, t);
+}
+
+static void
+mm_broadband_modem_fm350gl_init(MMBroadbandModemFM350GL *self)
+{
+  // Must be there otherwise the bearer functions of
+  // the individual bearer will not be used?
+}
+
+static void
+mm_broadband_modem_fm350gl_class_init(MMBroadbandModemFM350GLClass *klass)
+{
+  klass->enabling_modem_init = enabling_modem_init;
+}
+
+static void
+enabling_modem_init(MMBroadbandModem *m,
+                    GAsyncReadyCallback cb,
+                    gpointer userdata)
+{
+  MMPortSerialAt *primary = mm_base_modem_peek_port_primary(MM_BASE_MODEM(m));
+  if (!primary)
+  {
+    g_task_report_new_error(
+        m, cb, userdata, enabling_modem_init,
+        MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+        "Failed to run init command: primary port missing");
+    return;
+  }
+  // initialization ATZ0 instead of ATZ
+  mm_base_modem_at_command_full(
+      MM_BASE_MODEM(m), primary, "Z0", 6, FALSE,
+      FALSE, NULL, cb, userdata);
+}
--- /dev/null
+++ b/src/plugins/fm350gl/mm-broadband-modem-fm350gl.h
@@ -0,0 +1,54 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) GiauTM
+ * Copyright (C) PMGZED
+ * Copyright (C) ModemManager Team
+ */
+
+#ifndef MM_BROADBAND_MODEM_FM350GL_H
+#define MM_BROADBAND_MODEM_FM350GL_H
+
+#include "mm-broadband-modem.h"
+
+#define MM_TYPE_BROADBAND_MODEM_FM350GL (mm_broadband_modem_fm350gl_get_type())
+#define MM_BROADBAND_MODEM_FM350GL(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), MM_TYPE_BROADBAND_MODEM_FM350GL, MMBroadbandModemFM350GL))
+#define MM_BROADBAND_MODEM_FM350GL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), MM_TYPE_BROADBAND_MODEM_FM350GL, MMBroadbandModemFM350GLClass))
+#define MM_IS_BROADBAND_MODEM_FM350GL(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), MM_TYPE_BROADBAND_MODEM_FM350GL))
+#define MM_IS_BROADBAND_MODEM_FM350GL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), MM_TYPE_BROADBAND_MODEM_FM350GL))
+#define MM_BROADBAND_MODEM_FM350GL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS((obj), MM_TYPE_BROADBAND_MODEM_FM350GL, MMBroadbandModemFM350GLClass))
+
+typedef struct _MMBroadbandModemFM350GL MMBroadbandModemFM350GL;
+typedef struct _MMBroadbandModemClass MMBroadbandModemFM350GLClass;
+typedef struct _MMBroadbandModemFM350GLPrivate MMBroadbandModemFM350GLPrivate;
+
+struct _MMBroadbandModemFM350GL
+{
+  MMBroadbandModem parent;
+  MMBroadbandModemFM350GLPrivate *priv;
+};
+
+struct _MMBroadbandModemFM350GLClass
+{
+  MMBroadbandModemClass parent;
+};
+
+GType mm_broadband_modem_fm350gl_get_type(void);
+
+MMBroadbandModemFM350GL *
+mm_broadband_modem_FM350GL_new(const gchar *device,
+                               const gchar *physdev,
+                               const gchar **drivers,
+                               const gchar *plugin,
+                               guint16 vid,
+                               guint16 pid);
+
+#endif /* MM_BROADBAND_MODEM_FM350GL_H */
--- /dev/null
+++ b/src/plugins/fm350gl/mm-plugin-fm350gl.c
@@ -0,0 +1,88 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) GiauTM
+ * Copyright (C) PMGZED
+ * Copyright (C) ModemManager Team
+ */
+
+#include <string.h>
+#include <termios.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <time.h>
+
+#include <gmodule.h>
+
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include "mm-plugin-common.h"
+#include "mm-broadband-modem.h"
+#include "mm-serial-parsers.h"
+#include "mm-log-object.h"
+#include "mm-iface-modem.h"
+
+#include "mm-broadband-modem-fm350gl.h"
+
+#define MM_TYPE_PLUGIN_FM350GL mm_plugin_fm350gl_get_type()
+
+MM_DEFINE_PLUGIN(FM350GL, fm350gl, FM350GL)
+
+MM_PLUGIN_NAMED_CREATOR_SCOPE MMPlugin *
+mm_plugin_create_fm350gl(void)
+{
+    static const gchar *subsystems[] = {"tty", "net", NULL};
+    static const mm_uint16_pair pids[] = {
+        {0x0e8d, 0x7126},
+        {0x0e8d, 0x7127},
+    };
+    return MM_PLUGIN(g_object_new(
+        MM_TYPE_PLUGIN_FM350GL,
+        MM_PLUGIN_NAME, MM_MODULE_NAME,
+        MM_PLUGIN_ALLOWED_SUBSYSTEMS, subsystems,
+        MM_PLUGIN_ALLOWED_PRODUCT_IDS, pids,
+        MM_PLUGIN_ALLOWED_AT, TRUE,
+        MM_PLUGIN_ICERA_PROBE, FALSE,
+        MM_PLUGIN_REMOVE_ECHO, TRUE,
+        NULL));
+}
+
+static void
+mm_plugin_fm350gl_init(MMPluginFM350GL *self)
+{
+}
+
+static MMBaseModem *
+create_modem(MMPlugin *p,
+             const gchar *uid,
+             const gchar *physdev,
+             const gchar **drivers,
+             guint16 vid,
+             guint16 pid,
+             guint16 subsystem_vendor,
+             GList *probes,
+             GError **err)
+{
+    return MM_BASE_MODEM(mm_broadband_modem_FM350GL_new(
+        uid, physdev, drivers, mm_plugin_get_name(p), vid, pid));
+}
+
+static void
+mm_plugin_fm350gl_class_init(MMPluginFM350GLClass *klass)
+{
+    MMPluginClass *p = MM_PLUGIN_CLASS(klass);
+    p->create_modem = create_modem;
+}
--- a/src/plugins/meson.build
+++ b/src/plugins/meson.build
@@ -697,6 +697,22 @@ if plugins_options['option']
   }}
 endif
 
+# plugin: option fm350gl
+if plugins_options['fm350gl']
+  sources = files(
+    'fm350gl/mm-plugin-fm350gl.c',
+    'fm350gl/mm-broadband-bearer-fm350gl.c',
+    'fm350gl/mm-broadband-modem-fm350gl.c',
+  )
+
+  plugins += {'plugin-fm350gl': {
+    'plugin': true,
+    'module': {'sources': sources, 'include_directories': plugins_incs, 'c_args': '-DMM_MODULE_NAME="fm350gl"'},
+  }}
+
+  plugins_udev_rules += files('fm350gl/77-mm-fm350gl.rules')
+endif
+
 # plugin: option hso
 if plugins_options['option-hso']
   sources = files(
--- a/src/plugins/mm-builtin-plugins.c
+++ b/src/plugins/mm-builtin-plugins.c
@@ -109,6 +109,9 @@ MMPlugin *mm_plugin_create_samsung (void
 #if defined ENABLE_PLUGIN_SIERRA
 MMPlugin *mm_plugin_create_sierra (void);
 #endif
+#if defined ENABLE_PLUGIN_FM350GL
+MMPlugin *mm_plugin_create_fm350gl (void);
+#endif
 #if defined ENABLE_PLUGIN_SIERRA_LEGACY
 MMPlugin *mm_plugin_create_sierra_legacy (void);
 #endif
@@ -238,6 +241,9 @@ mm_builtin_plugins_load (void)
 #if defined ENABLE_PLUGIN_SIERRA
     PREPEND_PLUGIN (sierra);
 #endif
+#if defined ENABLE_PLUGIN_FM350GL
+    PREPEND_PLUGIN (fm350gl);
+#endif
 #if defined ENABLE_PLUGIN_SIERRA_LEGACY
     PREPEND_PLUGIN (sierra_legacy);
 #endif
